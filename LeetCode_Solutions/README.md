# LeetCode Solutions
**Purpose:** Describe the work done in this category based on the August 2025 study schedule.

## Updates Log 
| Date | Summary |
|------|---------|
| 2025-10-09 | Solved LeetCode Problem #210: Course Schedule II (Medium, Array/Depth-First Search/Breadth-First Search/Graph/Topological Sort) - Implemented both initial complex solution using ordering dictionary with depth calculation and optimal DFS solution with three-state tracking (unvisited/visiting/visited). The optimal solution uses standard topological sorting with post-order DFS traversal and cycle detection. Achieved O(V+E) time complexity and O(V+E) space complexity for both approaches |
| 2025-10-07 | Solved LeetCode Problem #417: Pacific Atlantic Water Flow (Medium, Array/Depth-First Search/Breadth-First Search/Matrix) - Couldn't solve this one until seeing the solution. Implemented optimal reverse BFS approach starting from ocean borders and flowing upward to find cells reachable by both oceans. Achieved O(m*n) time complexity and O(m*n) space complexity. Included my initial DFS attempt that had memoization and path-tracking issues |
| 2025-10-06 | Solved LeetCode Problem #133: Clone Graph (Medium, Hash Table/Depth-First Search/Breadth-First Search/Graph) - Implemented BFS solution using hash map to track cloned nodes and queue for traversal. Achieved O(N+M) time complexity and O(N) space complexity. Also provided alternative DFS recursive solution for comparison |
| 2025-10-04 | Solved LeetCode Problem #70: Climbing Stairs (Easy, Dynamic Programming/Math/Memoization) - Implemented optimal space-optimized DP solution using Fibonacci sequence approach with O(n) time complexity and O(1) space complexity. Also provided alternative recursive memoized and DP array solutions for comparison |
| 2025-10-03 | Solved LeetCode Problem #236: Lowest Common Ancestor of a Binary Tree (Medium, Tree/Depth-First Search/Binary Tree) - Implemented recursive DFS solution that searches for both nodes and identifies LCA when both subtrees return non-null results. Achieves O(n) time complexity and O(h) space complexity for recursion stack |
| 2025-10-03 | Solved LeetCode Problem #235: Lowest Common Ancestor of a Binary Search Tree (Medium, Tree/Depth-First Search/Binary Search Tree/Binary Tree) - Implemented optimal iterative solution leveraging BST property to navigate left/right based on node values. Achieves O(h) time complexity and O(1) space complexity. Also provided recursive alternative with O(h) space |
| 2025-10-02 | Solved LeetCode Problem #297: Serialize and Deserialize Binary Tree (Hard, String/Tree/Depth-First Search/Breadth-First Search/Design/Binary Tree) - Implemented both initial solution using empty strings for null nodes and optimal solution using explicit "null" markers. The optimal approach uses preorder traversal with iterator pattern for cleaner deserialization, achieving O(n) time complexity for both operations |
| 2025-10-01 | Solved LeetCode Problem #25: Reverse Nodes in k-Group (Hard, Linked List/Recursion) - Implemented optimal O(1) space solution using dummy node technique with in-place k-group reversal. Also provided alternative recursive approach with O(n/k) space complexity. The optimal solution reverses nodes in groups of k while maintaining constant space |
| 2025-09-30 | Solved LeetCode Problem #704: Binary Search (Easy, Array/Binary Search) - Implemented classic iterative binary search with O(log n) time complexity and O(1) space complexity. Also provided recursive solution and bisect module approach for comparison |
| 2025-09-30 | Solved LeetCode Problem #98: Validate Binary Search Tree (Medium, Tree/Depth-First Search/Binary Search Tree/Binary Tree) - Implemented recursive DFS solution with range validation using min/max bounds to validate BST property. Also provided alternative iterative solution using inorder traversal. Both achieve O(n) time complexity and O(h) space complexity |
| 2025-09-29 | Solved LeetCode Problem #103: Binary Tree Zigzag Level Order Traversal (Medium, Tree/Breadth-First Search/Binary Tree) - Implemented two approaches: initial solution using reverse() for odd levels and optimal solution using deque with directional appending (appendleft/append). The optimal approach avoids the reverse operation by building levels in correct order from the start |
| 2025-09-29 | Solved LeetCode Problem #102: Binary Tree Level Order Traversal (Medium, Tree/Breadth-First Search/Binary Tree) - Implemented three different approaches: initial DFS with instance variable, cleaner DFS using nested helper function, and optimal BFS solution using queue. The BFS approach is most intuitive for level order traversal with O(n) time complexity and O(w) space complexity where w is maximum tree width |
| 2025-09-28 | Solved LeetCode Problem #142: Linked List Cycle II (Medium, Hash Table/Linked List/Two Pointers) - Implemented both hash set solution with O(n) space and optimal Floyd's Cycle Detection Algorithm (two-phase approach) with O(1) space. The optimal solution uses mathematical proof to find cycle start: after detecting cycle with slow/fast pointers, reset slow to head and move both one step at a time until they meet at cycle beginning |
| 2025-09-27 | Solved LeetCode Problem #19: Remove Nth Node From End of List (Medium, Linked List/Two Pointers) - Implemented both initial solution using three pointers (old, slow, fast) and optimal solution using dummy node technique. Both achieve O(n) time complexity and O(1) space complexity. The optimal solution uses dummy node to simplify edge case handling when removing the head node |
| 2025-09-26 | Solved LeetCode Problem #226: Invert Binary Tree (Easy, Tree/DFS/BFS/Binary Tree) - Implemented recursive solution with in-place swapping and provided alternative iterative solutions using both BFS queue and DFS stack approaches. Achieved O(n) time complexity and O(h) space complexity for tree inversion |
| 2025-09-26 | Solved LeetCode Problem #100: Same Tree (Easy, Tree/DFS/BFS/Binary Tree) - Implemented recursive solution with elegant logic using short-circuit evaluation and provided alternative iterative solution using stack. Achieved O(min(m,n)) time complexity and space complexity for comparing structural and value equality of binary trees |
| 2025-09-26 | Solved LeetCode Problem #104: Maximum Depth of Binary Tree (Easy, Tree/DFS/BFS/Binary Tree) - Implemented three different approaches: initial solution with explicit depth tracking, optimal recursive solution incrementing on return, and iterative BFS solution using level-order traversal. All achieve O(n) time complexity with different space considerations |
| 2025-09-25 | Solved LeetCode Problem #141: Linked List Cycle (Easy, Hash Table/Linked List/Two Pointers) - Implemented both hash set solution with O(n) space and optimal Floyd's Cycle Detection Algorithm (two pointers) with O(1) space complexity. The optimal solution uses slow/fast pointers to detect cycles, satisfying the follow-up requirement for constant memory usage |
| 2025-09-24 | Solved LeetCode Problem #21: Merge Two Sorted Lists (Easy, Linked List) - Implemented both dummy node approach (optimal) and direct pointer manipulation solution. Achieved O(n+m) time complexity and O(1) space complexity for merging two sorted linked lists by splicing nodes together |
| 2025-09-23 | Solved LeetCode Problem #143: Reorder List (Medium, Linked List/Two Pointers/Stack/Recursion) - Implemented optimal three-step solution: find middle using slow/fast pointers, reverse second half, then merge alternately. Achieved O(n) time complexity and O(1) space complexity, beating 100.00% of users |
| 2025-09-20 | Solved LeetCode Problem #23: Merge k Sorted Lists (Hard, Linked List/Divide and Conquer/Heap/Merge Sort) - Implemented heap-based solution using min heap with O(N log k) time complexity and O(k) space complexity, plus alternative divide and conquer approach for merging k sorted linked lists |
| 2025-09-19 | Solved LeetCode Problem #42: Trapping Rain Water (Hard, Array/Two Pointers/Dynamic Programming/Stack/Monotonic Stack) - Implemented both unoptimized queue-based solution and optimized monotonic stack solution with O(n) time complexity for calculating trapped rainwater between elevation bars |
| 2025-09-18 | Solved LeetCode Problem #76: Minimum Window Substring (Hard, Hash Table/String/Sliding Window) - Implemented both unoptimized solution with O(m*n) validation and optimal sliding window solution with O(m+n) time complexity using character frequency tracking and formed counter optimization |
| 2025-09-16 | Solved LeetCode Problem #11: Container With Most Water (Medium, Array/Two Pointers/Greedy) - Implemented two pointers technique starting from widest container and moving inward based on smaller height, achieving O(n) time complexity and O(1) space complexity |
| 2025-09-16 | Solved LeetCode Problem #647: Palindromic Substrings (Medium, String/Dynamic Programming) - Implemented expand around centers approach to count all palindromic substrings, achieving O(n²) time complexity and O(1) space complexity |
| 2025-09-16 | Solved LeetCode Problem #5: Longest Palindromic Substring (Medium, String/Dynamic Programming) - Implemented expand around centers approach with early termination optimization, achieving O(n²) time complexity and O(1) space complexity |
| 2025-09-14 | Solved LeetCode Problem #49: Group Anagrams (Medium, Array/Hash Table/String/Sorting) - Implemented both sorted-key solution (beats 99% users) with O(n*m*log m) complexity and character frequency counting solution with O(n*m) complexity |
| 2025-09-13 | Solved LeetCode Problem #424: Longest Repeating Character Replacement (Medium, String/Sliding Window/Hash Table) - Implemented both unoptimized O(n²) solution expanding from each position and optimized O(n) sliding window solutionusing character frequency counting |
| 2025-09-11 | Solved LeetCode Problem #435: Non-overlapping Intervals (Medium, Array/Dynamic Programming/Greedy/Sorting) - Implemented both initial solution sorting by start time and optimal solution sorting by end time with O(n log n) time complexity and O(1) space complexity for finding minimum intervals to remove |
| 2025-09-10 | Solved LeetCode Problem #57: Insert Interval (Medium, Array/Sorting) - Implemented optimized three-phase solution with O(n) time complexity and O(n) space complexity for inserting and merging intervals |
| 2025-09-10 | Solved LeetCode Problem #56: Merge Intervals (Medium, Array/Sorting) - Implemented solution using sorting by start time and greedy merging approach with O(n log n) time complexity for sorting and O(1) extra space complexity |
| 2025-09-08 | Solved LeetCode Problem #53: Maximum Subarray (Medium, Array/Dynamic Programming/Divide and Conquer) - Implemented Kadane's algorithm with O(n) time and O(1) space complexity for finding maximum sum contiguous subarray |
| 2025-09-08 | Solved LeetCode Problem #238: Product of Array Except Self (Medium, Array/Prefix Sum) - Implemented two-pass solution using left and right product arrays with O(n) time and O(1) extra space complexity (output array doesn't count as extra space) |
| 2025-09-05 | Solved LeetCode Problem #206: Reverse Linked List (Easy, Linked List/Recursion) - Implemented both iterative and recursive solutions with O(n) time complexity, iterative uses O(1) space while recursive uses O(n) space due to call stack |
| 2025-09-03 | Solved LeetCode Problem #242: Valid Anagram (Easy, Hash Table/String/Sorting) - Implemented dictionary-based solution using character frequency counting with simultaneous increment/decrement approach for O(n) time and O(1) space complexity |
| 2025-09-02 | Solved LeetCode Problem #121: Best Time to Buy and Sell Stock (Easy, Array/Dynamic Programming) - Implemented optimized one-pass solution using minimum price tracking with O(n) time and O(1) space complexity |
| 2025-08-12 | Solved LeetCode Problem #3: Longest Substring Without Repeating Characters (Medium, String/Hash Table/Sliding Window) - Implemented both initial and optimized solutions using sliding window technique with 18ms/25ms runtime performance |
| 2025-08-12 | Solved LeetCode Problem #200: Number of Islands (Medium, Array/DFS/BFS/Matrix) - Implemented both recursive DFS (timeout) and optimized BFS solutions using queue and in-place modification |
| 2025-08-12 | Solved LeetCode Problem #146: LRU Cache (Medium, Hash Table/Linked List/Design) - Implemented LRU cache using OrderedDict with O(1) operations achieving 95ms runtime and 77.89MB memory usage |
