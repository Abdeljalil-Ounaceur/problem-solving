# LeetCode Solutions
**Purpose:** Describe the work done in this category based on the August 2025 study schedule.

## Updates Log
| Date | Summary |
|------|---------|
| 2025-10-27 | Solved LeetCode Problem #208: Implement Trie (Prefix Tree) (Medium, Hash Table/String/Design/Trie) - Implemented Trie data structure using dictionary-based approach with two solutions: one using None as end marker and one using "#" as end marker for clearer dictionary operations. Both implementations provide insert, search, and startsWith operations with O(m) time complexity where m is key length. Space complexity is O(total characters stored). Key insight: Trie enables efficient prefix-based operations, making it ideal for autocomplete and spellchecking applications |
| 2025-10-26 | Solved LeetCode Problem #22: Generate Parentheses (Medium, String/Dynamic Programming/Backtracking) - Implemented both DP solution using Catalan number pattern with defaultdict and optimal backtracking solution building valid combinations character by character. The DP approach generates combinations by wrapping previous results with parentheses pairs, while the optimal backtracking solution directly builds valid strings by tracking open/close counts and ensuring closing parentheses never exceed opening ones at any point. Both achieve O(4^n / sqrt(n)) time complexity for generating all valid combinations. Key insight: backtracking approach is more intuitive and avoids generating invalid combinations entirely |
| 2025-10-25 | Solved LeetCode Problem #150: Evaluate Reverse Polish Notation (Medium, Array/Math/Stack) - Implemented stack-based solution for evaluating RPN expressions. The approach uses a stack to store operands, pushing numbers onto the stack and popping two operands when encountering an operator (+, -, *, /). Key insight: pop order matters (second pop is left operand, first pop is right operand), and int(a/b) correctly truncates toward zero for both positive and negative division. Achieved O(n) time complexity and O(n) space complexity. Also provided alternative solution using operator dictionary with lambda functions |
| 2025-10-24 | Solved LeetCode Problem #221: Maximal Square (Medium, Array/Dynamic Programming/Matrix) - Implemented both initial solution using in-place DP modification and optimal space-optimized solution using two 1D arrays. The initial approach converts matrix to integers and uses DP where each cell stores the side length of largest square ending there, computed as min of three neighbors + 1. The optimal solution reduces space from O(m*n) to O(n) by using only prev and curr row arrays. Achieved O(m*n) time complexity with O(n) space complexity for optimal solution. Key insight: DP recurrence dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 when cell is '1', and only previous row needed for computation |
| 2025-10-24 | Solved LeetCode Problem #91: Decode Ways (Medium, String/Dynamic Programming) - Implemented both initial solution with complex state tracking and optimal clean DP solution. The optimal approach uses two variables (prev2, prev1) to track DP states, checking at each position if single-digit decode (not '0') or two-digit decode (10-26) is valid, then summing ways from both possibilities. Achieved O(n) time complexity and O(1) space complexity. Key insight: similar to climbing stairs problem where current ways = sum of ways from previous valid decode options. Also provided alternative explicit DP array solution for clarity |
| 2025-10-21 | Solved LeetCode Problem #64: Minimum Path Sum (Medium, Array/Dynamic Programming/Matrix) - Implemented both initial solution and cleaner version with explicit dimensions. The approach uses in-place DP modification of the grid, initializing first column (cumulative sum from top) and first row (cumulative sum from left), then filling remaining cells by adding minimum of cell above or cell to the left. Achieved O(m*n) time complexity and O(1) space complexity by modifying grid in-place. Key insight: at each cell, minimum path sum = current value + min(path sum from above, path sum from left) |
| 2025-10-20 | Solved LeetCode Problem #62: Unique Paths (Medium, Math/Dynamic Programming/Combinatorics) - Implemented both initial 2D DP grid solution and optimal space-optimized 1D array solution. The initial approach creates a full m×n grid where grid[i][j] represents unique paths to reach that cell, with base cases of 1 for first row and column. The optimal solution uses a single row array updated in-place, leveraging the insight that we only need the previous row to compute the current row. At each position, paths = paths from above + paths from left. Achieved O(m*n) time complexity with O(n) space complexity for the optimal solution |
| 2025-10-20 | Solved LeetCode Problem #377: Combination Sum IV (Medium, Array/Dynamic Programming) - Implemented both initial solution with minimum value optimization and cleaner optimal solution. The key insight is using bottom-up DP where dp[i] represents number of combinations that sum to i, with base case dp[0] = 1. Unlike Combination Sum problems, this counts permutations (order matters), so outer loop iterates through targets not nums. For each target, try all numbers and sum combinations from (target - num). Achieved O(target * len(nums)) time complexity and O(target) space complexity |
| 2025-10-18 | Solved LeetCode Problem #139: Word Break (Medium, Array/Hash Table/String/Dynamic Programming/Trie/Memoization) - Implemented three approaches: standard textbook DP solution checking all splits at each position, initial solution using forward iteration with possible starts tracking and max_word_len optimization, and optimal solution extending from valid starts only with early pruning. The optimal approach skips invalid positions and limits search space using max word length, achieving O(n * maxLen) time complexity and O(n) space complexity. Key insight: tracking valid start positions and using max word length constraint significantly reduces unnecessary substring checks |
| 2025-10-17 | Solved LeetCode Problem #1143: Longest Common Subsequence (Medium, String/Dynamic Programming) - Failed to solve this problem within the time limit. Documented optimal 2D DP solution where dp[i][j] represents LCS length between text1[0:i] and text2[0:j]. Key insight: if characters match, extend previous LCS by 1 (dp[i-1][j-1] + 1); otherwise, take maximum from excluding either character (max(dp[i-1][j], dp[i][j-1])). Achieved O(m*n) time complexity and O(m*n) space complexity |
| 2025-10-16 | Solved LeetCode Problem #300: Longest Increasing Subsequence (Medium, Array/Binary Search/Dynamic Programming) - Implemented three approaches: initial solution using SortedDict (third-party library), standard O(n²) DP solution, and optimal O(n log n) binary search solution using Patience Sorting algorithm. The optimal solution maintains a list of smallest tail elements for all increasing subsequences and uses bisect_left to find insertion positions. Key insight: the maintained list doesn't necessarily contain an actual LIS, but its length equals the LIS length. Achieved O(n log n) time complexity and O(n) space complexity |
| 2025-10-15 | Solved LeetCode Problem #322: Coin Change (Medium, Array/Dynamic Programming/Breadth-First Search) - Implemented both initial solution with explicit min_value tracking and optimal cleaner solution with improved readability. The key insight is using bottom-up DP where dp[i] represents minimum coins needed for amount i, building up from base case dp[0] = 0. For each amount, try all coin denominations and take minimum. Achieved O(amount * coins) time complexity and O(amount) space complexity. The optimal solution adds check for dp[a - c] != infinity to avoid unnecessary operations |
| 2025-10-14 | Solved LeetCode Problem #213: House Robber II (Medium, Array/Dynamic Programming) - Implemented both optimal solution with inline logic and cleaner solution with extracted helper function. The key insight is reducing the circular house problem to two linear House Robber problems: one excluding the last house and one excluding the first house, since we cannot rob both first and last houses in a circle. Achieved O(n) time complexity and O(1) space complexity. Also provided cleaner refactored version using rob_linear() helper function following DRY principle |
| 2025-10-13 | Solved LeetCode Problem #198: House Robber (Medium, Array/Dynamic Programming) - Implemented both initial solution with array padding approach and optimal space-optimized solution using two variables. The optimal approach uses prev2 and prev1 to track previous states, making decision at each house: rob current (prev2 + n) or skip (prev1). Achieved O(n) time complexity and O(1) space complexity. Key insight: classic DP optimization similar to Fibonacci, only need last two states to make optimal decision |
| 2025-10-12 | Solved LeetCode Problem #153: Find Minimum in Rotated Sorted Array (Medium, Array/Binary Search) - Implemented both initial solution with complex conditional logic checking both left and right boundaries, and optimal solution with simplified logic comparing mid with right. The optimal approach determines which half contains the minimum by checking if nums[mid] > nums[right], moving to right half if true or left half (including mid) if false. Achieved O(log n) time complexity and O(1) space complexity. Key insight: comparing mid with right cleanly identifies rotation point location |
| 2025-10-11 | Solved LeetCode Problem #33: Search in Rotated Sorted Array (Medium, Array/Binary Search) - Implemented both unoptimized solution with complex conditional logic and optimal solution using sorted-half identification. The optimal approach identifies which half is sorted at each step and checks if target lies within that sorted portion. Achieved O(log n) time complexity and O(1) space complexity. Key insight: at any point in a rotated sorted array, at least one half must be sorted |
| 2025-10-10 | Solved LeetCode Problem #261: Graph Valid Tree (Medium, Graph/Depth-First Search/Breadth-First Search/Union Find/Tree) - Documented both incorrect directed tree interpretation (which passed by symmetry) and optimal undirected graph solution. Implemented DFS with parent tracking to detect cycles and verify connectivity. Also provided Union-Find alternative. Achieved O(n+e) time complexity and O(n+e) space complexity. Key insight: valid tree requires exactly n-1 edges, full connectivity, and no cycles |
| 2025-10-09 | Solved LeetCode Problem #210: Course Schedule II (Medium, Array/Depth-First Search/Breadth-First Search/Graph/Topological Sort) - Implemented both initial complex solution using ordering dictionary with depth calculation and optimal DFS solution with three-state tracking (unvisited/visiting/visited). The optimal solution uses standard topological sorting with post-order DFS traversal and cycle detection. Achieved O(V+E) time complexity and O(V+E) space complexity for both approaches |
| 2025-10-07 | Solved LeetCode Problem #417: Pacific Atlantic Water Flow (Medium, Array/Depth-First Search/Breadth-First Search/Matrix) - Couldn't solve this one until seeing the solution. Implemented optimal reverse BFS approach starting from ocean borders and flowing upward to find cells reachable by both oceans. Achieved O(m*n) time complexity and O(m*n) space complexity. Included my initial DFS attempt that had memoization and path-tracking issues |
| 2025-10-06 | Solved LeetCode Problem #133: Clone Graph (Medium, Hash Table/Depth-First Search/Breadth-First Search/Graph) - Implemented BFS solution using hash map to track cloned nodes and queue for traversal. Achieved O(N+M) time complexity and O(N) space complexity. Also provided alternative DFS recursive solution for comparison |
| 2025-10-04 | Solved LeetCode Problem #70: Climbing Stairs (Easy, Dynamic Programming/Math/Memoization) - Implemented optimal space-optimized DP solution using Fibonacci sequence approach with O(n) time complexity and O(1) space complexity. Also provided alternative recursive memoized and DP array solutions for comparison |
| 2025-10-03 | Solved LeetCode Problem #236: Lowest Common Ancestor of a Binary Tree (Medium, Tree/Depth-First Search/Binary Tree) - Implemented recursive DFS solution that searches for both nodes and identifies LCA when both subtrees return non-null results. Achieves O(n) time complexity and O(h) space complexity for recursion stack |
| 2025-10-03 | Solved LeetCode Problem #235: Lowest Common Ancestor of a Binary Search Tree (Medium, Tree/Depth-First Search/Binary Search Tree/Binary Tree) - Implemented optimal iterative solution leveraging BST property to navigate left/right based on node values. Achieves O(h) time complexity and O(1) space complexity. Also provided recursive alternative with O(h) space |
| 2025-10-02 | Solved LeetCode Problem #297: Serialize and Deserialize Binary Tree (Hard, String/Tree/Depth-First Search/Breadth-First Search/Design/Binary Tree) - Implemented both initial solution using empty strings for null nodes and optimal solution using explicit "null" markers. The optimal approach uses preorder traversal with iterator pattern for cleaner deserialization, achieving O(n) time complexity for both operations |
| 2025-10-01 | Solved LeetCode Problem #25: Reverse Nodes in k-Group (Hard, Linked List/Recursion) - Implemented optimal O(1) space solution using dummy node technique with in-place k-group reversal. Also provided alternative recursive approach with O(n/k) space complexity. The optimal solution reverses nodes in groups of k while maintaining constant space |
| 2025-09-30 | Solved LeetCode Problem #704: Binary Search (Easy, Array/Binary Search) - Implemented classic iterative binary search with O(log n) time complexity and O(1) space complexity. Also provided recursive solution and bisect module approach for comparison |
| 2025-09-30 | Solved LeetCode Problem #98: Validate Binary Search Tree (Medium, Tree/Depth-First Search/Binary Search Tree/Binary Tree) - Implemented recursive DFS solution with range validation using min/max bounds to validate BST property. Also provided alternative iterative solution using inorder traversal. Both achieve O(n) time complexity and O(h) space complexity |
| 2025-09-29 | Solved LeetCode Problem #103: Binary Tree Zigzag Level Order Traversal (Medium, Tree/Breadth-First Search/Binary Tree) - Implemented two approaches: initial solution using reverse() for odd levels and optimal solution using deque with directional appending (appendleft/append). The optimal approach avoids the reverse operation by building levels in correct order from the start |
| 2025-09-29 | Solved LeetCode Problem #102: Binary Tree Level Order Traversal (Medium, Tree/Breadth-First Search/Binary Tree) - Implemented three different approaches: initial DFS with instance variable, cleaner DFS using nested helper function, and optimal BFS solution using queue. The BFS approach is most intuitive for level order traversal with O(n) time complexity and O(w) space complexity where w is maximum tree width |
| 2025-09-28 | Solved LeetCode Problem #142: Linked List Cycle II (Medium, Hash Table/Linked List/Two Pointers) - Implemented both hash set solution with O(n) space and optimal Floyd's Cycle Detection Algorithm (two-phase approach) with O(1) space. The optimal solution uses mathematical proof to find cycle start: after detecting cycle with slow/fast pointers, reset slow to head and move both one step at a time until they meet at cycle beginning |
| 2025-09-27 | Solved LeetCode Problem #19: Remove Nth Node From End of List (Medium, Linked List/Two Pointers) - Implemented both initial solution using three pointers (old, slow, fast) and optimal solution using dummy node technique. Both achieve O(n) time complexity and O(1) space complexity. The optimal solution uses dummy node to simplify edge case handling when removing the head node |
| 2025-09-26 | Solved LeetCode Problem #226: Invert Binary Tree (Easy, Tree/DFS/BFS/Binary Tree) - Implemented recursive solution with in-place swapping and provided alternative iterative solutions using both BFS queue and DFS stack approaches. Achieved O(n) time complexity and O(h) space complexity for tree inversion |
| 2025-09-26 | Solved LeetCode Problem #100: Same Tree (Easy, Tree/DFS/BFS/Binary Tree) - Implemented recursive solution with elegant logic using short-circuit evaluation and provided alternative iterative solution using stack. Achieved O(min(m,n)) time complexity and space complexity for comparing structural and value equality of binary trees |
| 2025-09-26 | Solved LeetCode Problem #104: Maximum Depth of Binary Tree (Easy, Tree/DFS/BFS/Binary Tree) - Implemented three different approaches: initial solution with explicit depth tracking, optimal recursive solution incrementing on return, and iterative BFS solution using level-order traversal. All achieve O(n) time complexity with different space considerations |
| 2025-09-25 | Solved LeetCode Problem #141: Linked List Cycle (Easy, Hash Table/Linked List/Two Pointers) - Implemented both hash set solution with O(n) space and optimal Floyd's Cycle Detection Algorithm (two pointers) with O(1) space complexity. The optimal solution uses slow/fast pointers to detect cycles, satisfying the follow-up requirement for constant memory usage |
| 2025-09-24 | Solved LeetCode Problem #21: Merge Two Sorted Lists (Easy, Linked List) - Implemented both dummy node approach (optimal) and direct pointer manipulation solution. Achieved O(n+m) time complexity and O(1) space complexity for merging two sorted linked lists by splicing nodes together |
| 2025-09-23 | Solved LeetCode Problem #143: Reorder List (Medium, Linked List/Two Pointers/Stack/Recursion) - Implemented optimal three-step solution: find middle using slow/fast pointers, reverse second half, then merge alternately. Achieved O(n) time complexity and O(1) space complexity, beating 100.00% of users |
| 2025-09-20 | Solved LeetCode Problem #23: Merge k Sorted Lists (Hard, Linked List/Divide and Conquer/Heap/Merge Sort) - Implemented heap-based solution using min heap with O(N log k) time complexity and O(k) space complexity, plus alternative divide and conquer approach for merging k sorted linked lists |
| 2025-09-19 | Solved LeetCode Problem #42: Trapping Rain Water (Hard, Array/Two Pointers/Dynamic Programming/Stack/Monotonic Stack) - Implemented both unoptimized queue-based solution and optimized monotonic stack solution with O(n) time complexity for calculating trapped rainwater between elevation bars |
| 2025-09-18 | Solved LeetCode Problem #76: Minimum Window Substring (Hard, Hash Table/String/Sliding Window) - Implemented both unoptimized solution with O(m*n) validation and optimal sliding window solution with O(m+n) time complexity using character frequency tracking and formed counter optimization |
| 2025-09-16 | Solved LeetCode Problem #11: Container With Most Water (Medium, Array/Two Pointers/Greedy) - Implemented two pointers technique starting from widest container and moving inward based on smaller height, achieving O(n) time complexity and O(1) space complexity |
| 2025-09-16 | Solved LeetCode Problem #647: Palindromic Substrings (Medium, String/Dynamic Programming) - Implemented expand around centers approach to count all palindromic substrings, achieving O(n²) time complexity and O(1) space complexity |
| 2025-09-16 | Solved LeetCode Problem #5: Longest Palindromic Substring (Medium, String/Dynamic Programming) - Implemented expand around centers approach with early termination optimization, achieving O(n²) time complexity and O(1) space complexity |
| 2025-09-14 | Solved LeetCode Problem #49: Group Anagrams (Medium, Array/Hash Table/String/Sorting) - Implemented both sorted-key solution (beats 99% users) with O(n*m*log m) complexity and character frequency counting solution with O(n*m) complexity |
| 2025-09-13 | Solved LeetCode Problem #424: Longest Repeating Character Replacement (Medium, String/Sliding Window/Hash Table) - Implemented both unoptimized O(n²) solution expanding from each position and optimized O(n) sliding window solutionusing character frequency counting |
| 2025-09-11 | Solved LeetCode Problem #435: Non-overlapping Intervals (Medium, Array/Dynamic Programming/Greedy/Sorting) - Implemented both initial solution sorting by start time and optimal solution sorting by end time with O(n log n) time complexity and O(1) space complexity for finding minimum intervals to remove |
| 2025-09-10 | Solved LeetCode Problem #57: Insert Interval (Medium, Array/Sorting) - Implemented optimized three-phase solution with O(n) time complexity and O(n) space complexity for inserting and merging intervals |
| 2025-09-10 | Solved LeetCode Problem #56: Merge Intervals (Medium, Array/Sorting) - Implemented solution using sorting by start time and greedy merging approach with O(n log n) time complexity for sorting and O(1) extra space complexity |
| 2025-09-08 | Solved LeetCode Problem #53: Maximum Subarray (Medium, Array/Dynamic Programming/Divide and Conquer) - Implemented Kadane's algorithm with O(n) time and O(1) space complexity for finding maximum sum contiguous subarray |
| 2025-09-08 | Solved LeetCode Problem #238: Product of Array Except Self (Medium, Array/Prefix Sum) - Implemented two-pass solution using left and right product arrays with O(n) time and O(1) extra space complexity (output array doesn't count as extra space) |
| 2025-09-05 | Solved LeetCode Problem #206: Reverse Linked List (Easy, Linked List/Recursion) - Implemented both iterative and recursive solutions with O(n) time complexity, iterative uses O(1) space while recursive uses O(n) space due to call stack |
| 2025-09-03 | Solved LeetCode Problem #242: Valid Anagram (Easy, Hash Table/String/Sorting) - Implemented dictionary-based solution using character frequency counting with simultaneous increment/decrement approach for O(n) time and O(1) space complexity |
| 2025-09-02 | Solved LeetCode Problem #121: Best Time to Buy and Sell Stock (Easy, Array/Dynamic Programming) - Implemented optimized one-pass solution using minimum price tracking with O(n) time and O(1) space complexity |
| 2025-08-12 | Solved LeetCode Problem #3: Longest Substring Without Repeating Characters (Medium, String/Hash Table/Sliding Window) - Implemented both initial and optimized solutions using sliding window technique with 18ms/25ms runtime performance |
| 2025-08-12 | Solved LeetCode Problem #200: Number of Islands (Medium, Array/DFS/BFS/Matrix) - Implemented both recursive DFS (timeout) and optimized BFS solutions using queue and in-place modification |
| 2025-08-12 | Solved LeetCode Problem #146: LRU Cache (Medium, Hash Table/Linked List/Design) - Implemented LRU cache using OrderedDict with O(1) operations achieving 95ms runtime and 77.89MB memory usage |
